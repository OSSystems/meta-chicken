--- tags/0.91/dbus.scm	2012-02-22 15:09:54.000000000 -0200
+++ trunk/dbus.scm	2012-03-13 11:19:31.000000000 -0300
@@ -18,10 +18,25 @@
 		register-path
 		unsupported-type?
 		unsupported-type-signature
+
+		make-variant
 		variant?
 		variant-data
-		make-variant
-		auto-unbox-variants)
+		auto-unbox-variants
+
+		make-struct
+		struct?
+		struct-ref
+		struct-set!
+		auto-unbox-structs
+		vector->struct
+		struct->vector
+
+		string->object-path
+		object-path?
+		object-path->string
+		auto-unbox-object-paths
+	)
 	(import scheme chicken extras
 		(except foreign foreign-declare)
 		foreigners
@@ -49,6 +64,15 @@
 (define-record-printer (unsupported-type d out)
 	(fprintf out "#<unsupported-type ~s>" (unsupported-type-signature d)))
 
+;; Object path is a string which is a dbus path
+(define-record-type object-path
+	(string->object-path str)
+	object-path?
+	(str object-path->string))
+(define-record-printer (object-path d out)
+	(fprintf out "#<object-path ~s>" (object-path->string d)))
+(define auto-unbox-object-paths (make-parameter #f))
+
 ;; Scheme is a dynamically typed language, so fundamentally we don't
 ;; have a use for the "variant" concept; but since dbus has a variant type,
 ;; we need a way of representing one when preparing a message for marshalling.
@@ -67,6 +91,29 @@
 ;; about this low-level detail.
 (define auto-unbox-variants (make-parameter #f))
 
+;; A DBus struct is represented as a vector, but it's tagged for marshalling
+;; record definition as just a wrapped vector
+(define-record-type struct
+	(vector->struct data)
+	struct?
+	(data struct->vector))
+;; now a realistic constructor
+(define (make-struct . fields) (vector->struct (list->vector fields)))
+;; and realistic accessors
+(define (struct-ref struct idx) (vector-ref (struct->vector struct) idx))
+(define (struct-set! struct idx val) (vector-set! (struct->vector struct) idx val))
+;; pretty-printing
+(define-record-printer (struct v out)
+	(fprintf out "#,(struct ~S)" (struct->vector v)))
+;; If unboxing is turned on, when a "call"ed dbus service method
+;; returns a struct, it will look like a vector instead.  This is
+;; convenient if you know what to expect, but otherwise you will
+;; have some difficulty to distinguish a struct from an array.
+;; By default this feature is turned off, in the interest of having a
+;; representation that is the same as you will need to build when
+;; you want to send (marshall) a dbus message.
+(define auto-unbox-structs (make-parameter #f))
+
 ; Would want to do this:
 ; (define-foreign-enum (bus (enum "DBusBusType"))
 	; (session-bus DBUS_BUS_SESSION)
@@ -108,9 +155,12 @@
 (define type-signature  (foreign-value DBUS_TYPE_SIGNATURE int))
 (define type-array (foreign-value DBUS_TYPE_ARRAY int))
 (define type-dict-entry  (foreign-value DBUS_TYPE_DICT_ENTRY int))
-(define type-dict-begin  (foreign-value DBUS_DICT_ENTRY_BEGIN_CHAR int))
-(define type-dict-end  (foreign-value DBUS_DICT_ENTRY_END_CHAR int))
+(define type-dict-entry-begin  (foreign-value DBUS_DICT_ENTRY_BEGIN_CHAR int))
+(define type-dict-entry-end  (foreign-value DBUS_DICT_ENTRY_END_CHAR int))
 (define type-variant (foreign-value DBUS_TYPE_VARIANT int))
+(define type-struct (foreign-value DBUS_TYPE_STRUCT int))
+(define type-struct-begin  (foreign-value DBUS_STRUCT_BEGIN_CHAR int))
+(define type-struct-end  (foreign-value DBUS_STRUCT_END_CHAR int))
 
 (define make-context)
 (define send)
@@ -155,7 +205,7 @@
 		found
 	))
 
-(let (	[connections '()]	;; an alist mapping bus to DBusConnection ptrs
+(let ([connections '()]	;; an alist mapping bus to DBusConnection ptrs
 		[error (foreign-value "&err" c-pointer)]
 		;; indices in a "context" vector
 		[context-idx-ID 0]
@@ -234,7 +284,7 @@
 	;; return value is undefined
 	(define (tasset! tree val . keys)
 		(let ([key-list (if (pair? (car keys)) (car keys) keys)])
-			(let loop (	[rem-keys (cdr key-list)]
+			(let loop ([rem-keys (cdr key-list)]
 						[subtree (tassq tree (car key-list))]
 						[prev-key (car key-list)]
 						[prev-subtree tree])
@@ -289,6 +339,35 @@
 	(define make-message (foreign-lambda message-ptr "dbus_message_new_method_call"
 		c-string c-string c-string c-string))
 
+	(define make-error
+		(foreign-lambda* (c-pointer (struct "DBusError")) ()
+			 "DBusError err;
+        dbus_error_init(&err);
+        C_return(&err);"))
+
+	(define free-error!
+		(foreign-lambda* void (((c-pointer (struct "DBusError")) err))
+			"dbus_error_free(err);"))
+
+	(define (raise-dbus-error location err)
+		(let ((err-name 
+					 ((foreign-lambda* c-string (((c-pointer (struct "DBusError")) err))
+							"C_return(err->name);")
+						err))
+					(err-message
+					 ((foreign-lambda* c-string (((c-pointer (struct "DBusError")) err))
+							"C_return(err->message);")
+						err)))
+			(free-error! err)
+			(signal
+			 (make-composite-condition
+				(make-property-condition 'dbus-call)
+				(make-property-condition 'exn 
+																 'location location
+																 'message (string-append "(" err-name "): " err-message))
+				))))
+
+
 	;; todo: garbage-collect this
 	(define make-iter-append
 		(foreign-lambda* message-iter-ptr ((message-ptr msg))
@@ -300,6 +379,10 @@
 		(foreign-lambda* bool ((message-iter-ptr iter) (c-string v))
 			"C_return (dbus_message_iter_append_basic(iter, DBUS_TYPE_STRING, &v));"))
 
+	(define iter-append-basic-object-path
+		(foreign-lambda* bool ((message-iter-ptr iter) (c-string v))
+			"C_return (dbus_message_iter_append_basic(iter, DBUS_TYPE_OBJECT_PATH, &v));"))
+
 	(define iter-append-basic-bool
 		(foreign-lambda* bool ((message-iter-ptr iter) (bool v))
 			"C_return (dbus_message_iter_append_basic(iter, DBUS_TYPE_BOOLEAN, &v));"))
@@ -340,17 +423,20 @@
 ; (printf "value-signature ~s~%" val)
 		(cond
 			[(string? val) (ascii->string type-string)]
+			[(object-path? val) (ascii->string type-object-path)]
 			[(fixnum? val) (ascii->string type-fixnum)]
 			[(flonum? val) (ascii->string type-flonum)]
 			[(boolean? val) (ascii->string type-boolean)]
 			[(variant? val) (ascii->string type-variant)]
+			[(struct? val) (format "~a~a~a" (ascii->string type-struct-begin)
+				(apply string-append (map value-signature (vector->list (struct->vector val)))) (ascii->string type-struct-end))]
 			[(vector? val) (format "~a~a" (ascii->string type-array) (value-signature (vector-ref val 0)))]
 			; [(variant? val) (value-signature (variant-data val))]
 			[(pair? val)
 				(if (list? val)
 					"unsupported" ;; todo
-					(format "~a~a~a~a" (integer->char type-dict-begin)
-						(value-signature (car val)) (value-signature (cdr val))(integer->char type-dict-end))
+					(format "~a~a~a~a" (integer->char type-dict-entry-begin)
+						(value-signature (car val)) (value-signature (cdr val))(integer->char type-dict-entry-end))
 				)]
 		))
 
@@ -364,7 +450,21 @@
 					C_return(container);") iter signature)])
 				(iter-append-basic container val)
 				((foreign-lambda* bool ((message-iter-ptr iter)(message-iter-ptr container))
-					"C_return (dbus_message_iter_close_container(iter, container));") iter container) ) ))
+					"bool ret = dbus_message_iter_close_container(iter, container);
+					free(container);
+					C_return(ret);") iter container) ) ))
+
+	(define (iter-append-basic-struct iter val)
+; (printf "iter-append-basic-struct ~s~%" val)
+		(let ([container ((foreign-lambda* message-iter-ptr ((message-iter-ptr iter))
+				"DBusMessageIter* container = malloc(sizeof(DBusMessageIter));
+				dbus_message_iter_open_container(iter, DBUS_TYPE_STRUCT, NULL, container);
+				C_return(container);") iter)])
+			(vector-for-each (lambda (i field) (iter-append-basic container field)) val)
+			((foreign-lambda* bool ((message-iter-ptr iter)(message-iter-ptr container))
+				"bool ret = dbus_message_iter_close_container(iter, container);
+				free(container);
+				C_return (ret);") iter container) ) )
 
 	(define (iter-append-dict-entry iter pair)
 ; (printf "iter-append-dict-entry ~s : ~s~%" (car pair)(cdr pair))
@@ -376,7 +476,9 @@
 				(iter-append-basic container (car pair))
 				(iter-append-basic container (cdr pair))
 				((foreign-lambda* bool ((message-iter-ptr iter)(message-iter-ptr container))
-					"C_return (dbus_message_iter_close_container(iter, container));") iter container) ) ))
+					"bool ret = dbus_message_iter_close_container(iter, container);
+					free(container);
+					C_return(ret);") iter container) ) ))
 
 	;; The first element of the vector determines the signature, so all elements must have the same signature.
 	(define (iter-append-uniform-array iter vec)
@@ -393,17 +495,13 @@
 ; (printf "iter-append array element ~s ~s~%" i val)
 						(iter-append-basic container val) ) vec)
 					((foreign-lambda* bool ((message-iter-ptr iter)(message-iter-ptr container))
-						"C_return (dbus_message_iter_close_container(iter, container));") iter container) ) )
+						"bool ret = dbus_message_iter_close_container(iter, container);
+						free(container);
+						C_return(ret);") iter container) ) )
 			;; else todo: append empty array
 			))
 
-; (foreign-lambda* bool ((message-iter-ptr iter) (integer64 v))
-			; "dbus_message_iter_open_container(iter, DBUS_TYPE_VARIANT, signature, &value);
-			; dbus_message_iter_append_basic(&value, type, val);
-			; C_return (dbus_message_iter_close_container(iter, &value));")
-
-	;; TODO: iter-append-basic-T for each possible type:
-	;; especially struct might still be possible
+	;; TODO: iter-append-basic-object-path
 
 	;; val would usually be a single value, but
 	;; could be a pair of the form (type-x . value)
@@ -415,22 +513,32 @@
 			[(flonum? val) (iter-append-basic-double iter val)]
 			[(boolean? val) (iter-append-basic-bool iter val)]
 			[(variant? val) (iter-append-basic-variant iter (variant-data val))]
+			[(struct? val) (iter-append-basic-struct iter (struct->vector val))]
 			[(vector? val) (iter-append-uniform-array iter val)]
 			[(and (pair? val) (not (list? val))) (iter-append-dict-entry iter val)]
+			[(object-path? val) (iter-append-basic-object-path iter (object-path->string val))]
 			[else (iter-append-basic-string iter (any->string val))] ))
 
 	(define free-iter (foreign-lambda* void ((message-iter-ptr i)) "free(i);"))
 
 	(define (iter-cond iter)
-		(let (	[type ((foreign-lambda int "dbus_message_iter_get_arg_type"
+		(let ([type ((foreign-lambda int "dbus_message_iter_get_arg_type"
 						message-iter-ptr) iter)] )
 			; (printf "iter-cond type ~s~%" type)
 			(cond
-				[(memq type `(,type-string ,type-object-path))
+				[(eq? type type-string)
 					((foreign-lambda* c-string ((message-iter-ptr iter))
 						"char* ret = NULL;
 						dbus_message_iter_get_basic(iter, &ret);
 						C_return (ret);") iter)]
+				[(eq? type type-object-path)
+					(let ([str ((foreign-lambda* c-string ((message-iter-ptr iter))
+						"char* ret = NULL;
+						dbus_message_iter_get_basic(iter, &ret);
+						C_return (ret);") iter)])
+						(if (auto-unbox-object-paths)
+							str
+							(string->object-path str)))]
 				[(eq? type type-boolean)
 					((foreign-lambda* bool ((message-iter-ptr iter))
 						"bool ret;
@@ -465,6 +573,9 @@
 						v)]
 				[(eq? type type-dict-entry)
 					(iter->pair (make-sub-iter iter))]
+				[(eq? type type-struct)
+					(let ([v (iter->vector (make-sub-iter iter))])
+						(if (auto-unbox-structs) v (vector->struct v)))]
 				[(eq? type type-variant)
 					(if (auto-unbox-variants)
 						((make-sub-iter iter))
@@ -570,7 +681,7 @@
 		(foreign-lambda int "dbus_connection_send" connection-ptr message-ptr uint-ptr))
 
 	(set! send (lambda (context name . params)
-		(let* (	[service (symbol?->string (vector-ref context context-idx-service))]
+		(let* ([service (symbol?->string (vector-ref context context-idx-service))]
 				[msg (make-signal
 							(symbol?->string (vector-ref context context-idx-path))
 							(symbol?->string (vector-ref context context-idx-interface))
@@ -586,7 +697,7 @@
 			))))
 
 	(set! call (lambda (context name . params)
-		(let* (	[service (symbol->string (vector-ref context context-idx-service))]
+		(let* ([service (symbol->string (vector-ref context context-idx-service))]
 				[msg (make-message service
 							(symbol->string (vector-ref context context-idx-path))
 							(symbol->string (vector-ref context context-idx-interface))
@@ -597,29 +708,28 @@
 				(for-each (lambda (parm)
 					(iter-append-basic iter parm))	params)
 				(free-iter iter)
-				(let* (	[reply-msg ((foreign-lambda* message-ptr ((connection-ptr conn) (message-ptr msg))
-							;; idealistic code here; todo: error checking
+				(let* ([err (make-error)]
+							 [reply-msg ((foreign-lambda* message-ptr ((connection-ptr conn)
+																												 (message-ptr msg)
+																												 ((c-pointer (struct "DBusError")) err))
 							;; todo: timeout comes from where?  (make-parameter) maybe
 							"DBusMessage *reply;
-							DBusError error;
-							dbus_error_init (&error);
-							reply = dbus_connection_send_with_reply_and_block(conn, msg, 5000, &error);
-							if (dbus_error_is_set (&error))
-								fprintf (stderr, \"Error %s: %s\\n\", error.name, error.message);
-							else
-								fprintf (stderr, \"reply signature %s\\n\", dbus_message_get_signature(reply));
+							reply = dbus_connection_send_with_reply_and_block(conn, msg, 5000, err);
 							dbus_message_unref(msg);
-							C_return(reply);") conn msg) ]
-						[reply-iter (make-iter reply-msg)]
-						[reply-args (iter->list reply-iter)] )
-					reply-args)))))
+							C_return(reply);") conn msg err) ])
+					(if reply-msg
+							(let* ([reply-iter (make-iter reply-msg)]
+										 [reply-args (iter->list reply-iter)] )
+								reply-args)
+							(raise-dbus-error 'call err)))))))
+
 
 	(set! make-method-proxy (lambda (context name)
-		(let (	[service (symbol->string (vector-ref context context-idx-service))]
+		(let ([service (symbol->string (vector-ref context context-idx-service))]
 				[conn (conn-or-abort (vector-ref context context-idx-bus))] )
 				; (exists-or-abort conn (format "no connection to bus ~s~%" (vector-ref context context-idx-bus)))
 				(lambda params
-					(let* (	[msg (make-message service
+					(let* ([msg (make-message service
 									(symbol->string (vector-ref context context-idx-path))
 									(symbol->string (vector-ref context context-idx-interface))
 									name)]
@@ -628,7 +738,7 @@
 							(iter-append-basic iter parm))	params)
 						(free-iter iter)
 						;; TODO: pull this out into a helper function
-						(let* (	[reply-msg ((foreign-lambda* message-ptr ((connection-ptr conn) (message-ptr msg))
+						(let* ([reply-msg ((foreign-lambda* message-ptr ((connection-ptr conn) (message-ptr msg))
 									;; idealistic code here; todo: error checking
 									"DBusPendingCall* pending;
 									dbus_connection_send_with_reply(conn, msg, &pending, -1);
@@ -734,10 +844,10 @@
 	;; msg-cb is the user-provided one.
 	(define (method-wrapper conn msg-cb)
 		(lambda (msg)
-			(let (	[args (iter->list (make-iter msg))]
+			(let ([args (iter->list (make-iter msg))]
 					[response ((foreign-lambda message-ptr
 							"dbus_message_new_method_return" message-ptr) msg)])
-				(let (	[ret (apply msg-cb args)]
+				(let ([ret (apply msg-cb args)]
 						[iter (make-iter-append response)] )
 					(if (pair? ret)
 						(for-each (lambda (parm)
