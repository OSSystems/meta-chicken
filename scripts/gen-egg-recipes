#!/bin/sh
#| -*- scheme -*-
exec csi -s $0 "$@"
|#

;; This script requires the following external tools:
;; - wget
;; - md5
;; - sha256sum

(module gen-egg-recipes ()

(import chicken scheme)
(use posix setup-download setup-api srfi-1 srfi-13
     files extras data-structures utils ports)

(define egg-tarballs-uri
  "http://code.call-cc.org/egg-tarballs")

(define egg-tarballs-dir
  (normalize-pathname
   (make-pathname (current-directory) "egg-tarballs")))

(define recipes-extra-data-dir
  (normalize-pathname
   (make-pathname (current-directory) "recipes-extra-data")))

(define force? (make-parameter #f))

(define (die fmt . args)
  (with-output-to-port (current-error-port)
    (lambda ()
      (apply printf (cons fmt args))
      (newline)))
  (exit 1))

(define *egg-recipes-dir* #f)

(define *eggs-dir* #f)

(define all-eggs
  (map symbol->string
       '(awful-ssl
         channel
         connman
         crypt
         dbus
         expand-full
         foreigners
         free-gettext
         ini-file
         json
         make
         scron
         medea
         scss
         )))

(define self-dependent-eggs
  ;; Eggs that generate multiple modules that have interdependencies.
  ;; This script generates a -cross dependency for eggs that use
  ;; modules generated by themselves.
  '(awful
    scss
    spiffy
    ))

(define (self-dependent-egg? egg)
  (and (memq egg self-dependent-eggs) #t))

(define external-dependencies
  '((openssl openssl)
    (lzma    lzma)
    (ncurses ncurses)
    (readline readline)
    (xlib    libx11)
    (dbus    dbus)
    ))

(define (fix-license license)
  (if (and license (string? license)) ;; we can expect any data type
                                      ;; in the .meta file
      (cond ((string-ci=? license "public domain")
             "PD")
            ((string-ci=? license "LGPL-1")
             "LGPL")
            (else license))
      license))

(define (egg-external-dependencies egg)
  (let ((egg (if (string? egg)
                 (string->symbol egg)
                 egg)))
    (or (alist-ref egg external-dependencies) '())))

(define (latest-egg-version egg)
  (let ((versions
         (sort
          (string-split
           (list-extension-versions (->string egg) 'local *eggs-dir*)
           "\n")
          version>=?)))
    (if (null? versions)
        (error 'latest-egg-version
               (sprintf "Could not determine version for ~a" egg))
        (car versions))))

(define (meta-file-pathname egg version)
  (make-pathname (list *eggs-dir* egg "tags" version)
                 egg
                 "meta"))

(define (read-meta-file egg version)
  (with-input-from-file (meta-file-pathname egg version) read))

(define (meta-field key meta #!optional default)
  (or (and-let* ((d (assq key meta)))
                (cdr d))
      default))

(define (chicken-unit? lib)
  (and (member lib '("library" "eval" "expand" "data-strucutures" "ports"
                     "files" "extras" "irregex" "srfi-1" "srfi-4" "srfi-13"
                     "srfi-14" "srfi-18" "srfi-69" "posix" "utils" "tcp"
                     "lolevel" "foreign"))
       #t))

(define (egg-dependencies meta-data)
  (let* ((raw-deps (append
                    (meta-field 'depends meta-data '())
                    (meta-field 'needs meta-data '())))
         (deps (map (lambda (dep)
                      (->string (if (pair? dep)
                                    (car dep)
                                    dep)))
                    raw-deps)))
    ;; remove chicken and core units that some eggs [wrongly]
    ;; add to their dependencies
    (remove (lambda (egg)
              (or (equal? egg "chicken")
                  (chicken-unit? egg)))
            deps)))

(define (recipe-pathname egg version)
  (make-pathname *egg-recipes-dir*
                 (sprintf "chicken-egg-~a_~a.bb"
                          (string-downcase egg)
                          version)))

(define (hash-sum hash file)
  (car (string-split
        (call-with-input-pipe
         (sprintf "~asum ~a" hash file)
         read-all))))

(define (download-egg-tarball egg version)
  ;; Download tarball for egg/version.  Return a pair
  ;; (<md5sum> . <sha256sum>) for the downloaded tarball
  (create-directory egg-tarballs-dir 'with-parents)
  (let* ((tarball (sprintf "~a-~a.tar.gz" egg version))
         (tarball-uri (sprintf "~a/~a/~a" egg-tarballs-uri egg tarball))
         (downloaded-tarball
          (make-pathname egg-tarballs-dir tarball))
         (md5sum-file (string-append downloaded-tarball ".md5"))
         (sha256sum-file (string-append downloaded-tarball ".sha256")))
    (if (and (file-exists? downloaded-tarball)
             (file-exists? md5sum-file)
             (file-exists? sha256sum-file))
        (cons (read-all md5sum-file)
              (read-all sha256sum-file))
        (begin
          (printf "Downloading ~a ...\n" tarball-uri)
          (system* (sprintf "wget -q ~a -O ~a"
                            tarball-uri
                            downloaded-tarball))
          (let ((md5sum (hash-sum 'md5 downloaded-tarball))
                (sha256sum (hash-sum 'sha256 downloaded-tarball)))
            (with-output-to-file md5sum-file (cut display md5sum))
            (with-output-to-file sha256sum-file (cut display sha256sum))
            (cons md5sum sha256sum))))))

;;;
;;; Recipe generation
;;;
(define (format-description meta-data)
  (let ((description (meta-field 'synopsis meta-data)))
    (and description
         (sprintf "DESCRIPTION = \"~a\""
                  (string-translate* (car description) `(("`" . "")))))))

(define (format-license meta-data)
  (let ((license (meta-field 'license meta-data)))
    (sprintf "LICENSE = \"~a\""
             (if license
                 (fix-license (car license))
                 "Unknown"))))

(define (format-license-checksum egg version)
  (let ((meta-file (meta-file-pathname egg version)))
    (sprintf "LIC_FILES_CHKSUM = \"file://~a;md5=~a\""
             (pathname-strip-directory meta-file)
             (hash-sum 'md5 meta-file))))

(define (format-deps var deps)
  (if (null? deps)
      '()
      (list (sprintf "~a += \"~a\""
                     var
                     (string-intersperse deps)))))

(define (format-all-deps egg deps ext-deps)
  (let* ((deps-eggs (map egg->recipe deps))
         (deps-self-egg
          (if (self-dependent-egg? (string->symbol egg))
              (list (egg->recipe/cross egg))
              '()))
         (deps-pkg (map symbol->string ext-deps))
         (deps-pkg-cross (map egg->recipe/cross deps))
         (deps-pkg-native (map recipe->native ext-deps))
         (cross-deps (append deps-pkg-cross deps-pkg-native))
         (target-deps (append deps-eggs deps-pkg deps-pkg-cross deps-self-egg))
         (output
          (append
           (format-deps "DEPENDS_virtclass-cross" cross-deps)
           (format-deps "DEPENDS" target-deps)
           (format-deps "RDEPENDS_${PN}" deps-eggs))))
    (if (null? output)
        ""
        (string-append (string-intersperse output "\n") "\n"))))

(define (format-hash-sums egg version)
  (let ((hashes (download-egg-tarball egg version)))
    (sprintf "SRC_URI[md5sum] = \"~a\"\nSRC_URI[sha256sum] = \"~a\"\n"
             (car hashes)
             (cdr hashes))))

(define (egg-patches egg version)
  (let ((patches-dir
         (make-pathname *egg-recipes-dir*
                        (sprintf "chicken-egg-~a-~a"
                                 egg
                                 version))))
    (if (directory-exists? patches-dir)
        (directory patches-dir)
        '())))

(define (format-egg-patches patches)
  (string-intersperse
   (map (lambda (patch)
          (string-append "file://" patch))
        patches)
   " "))

(define (format-src-uri egg version)
  (let ((patches (egg-patches egg version)))
    (sprintf "SRC_URI = \"~a/${EGG}/${EGG}-${PV}.tar.gz~a\"\n"
             egg-tarballs-uri
             (if (null? patches)
                 ""
                 (string-append " " (format-egg-patches patches))))))

(define (format-recipe-extra-data egg version)
  (let ((extra-data-file
         (make-pathname recipes-extra-data-dir
                        (sprintf "~a_~a.red"
                                 egg
                                 version))))
    (if (file-exists? extra-data-file)
        (read-all extra-data-file)
        "")))

(define (egg->recipe egg)
  (conc "chicken-egg-" egg))

(define (egg->recipe/cross egg)
  (conc "chicken-egg-" egg "-cross"))

(define (recipe->native recipe)
  (conc recipe "-native"))

(define (gen-recipe egg)
  (let* ((version (latest-egg-version egg))
         (recipe-file (recipe-pathname egg version)))
    (when (or (force?) (not (file-exists? recipe-file)))
      (let* ((meta-data (read-meta-file egg version))
             (deps (egg-dependencies meta-data))
             (ext-deps (egg-external-dependencies egg))
             (has-deps? (or (not (null? ext-deps)) (not (null? deps))))
             (content
              (list
               "SECTION = \"devel/chicken\""
               (format-description meta-data)
               (format-license meta-data)
               (format-license-checksum egg version)
               (format-all-deps egg deps ext-deps)
               (format-src-uri egg version)
               (format-hash-sums egg version)
               "S = \"${WORKDIR}/${EGG}-${PV}\""
               (format-recipe-extra-data egg version)
               (string-append "inherit chicken_install\n")
               (string-append "BBCLASSEXTEND = \"cross\""))))
        (print (string-intersperse (list egg version (->string deps)) "\t"))
        (with-output-to-file recipe-file
          (lambda ()
            (print (string-intersperse (filter identity content) "\n"))))
        (when has-deps? (for-each gen-recipe deps))))))

(define (command-line-argument option args)
  ;; Returns the argument associated to the command line option OPTION
  ;; in ARGS or #f if OPTION is not found in ARGS or doesn't have any
  ;; argument.
  (let ((param/val (filter (lambda (opt)
                             (string-prefix? (conc option "=") opt))
                           args)))
    (and (not (null? param/val))
         (let ((tokens (string-split (last param/val) "=")))
           (string-intersperse (cdr tokens) "")))))

(define (usage #!optional exit-code)
  (let ((port (if (and exit-code (not (zero? exit-code)))
                  (current-error-port)
                  (current-output-port))))
    (fprintf port
             "~a --eggs-dir=<eggs-dir> --dest-dir=<dest dir> [ --force ]\n"
             (pathname-strip-directory (program-name))))
  (when exit-code (exit exit-code)))


(let ((args (command-line-arguments)))
  (when (null? args)
    (usage 1))

  (when (or (member "-h" args)
            (member "-help" args)
            (member "--help" args))
    (usage 0))

  (set! *eggs-dir* (command-line-argument '--eggs-dir args))
  (unless *eggs-dir* (die "Missing --eggs-dir=<eggs dir>"))

  (set! *egg-recipes-dir* (command-line-argument '--dest-dir args))
  (unless *egg-recipes-dir* (die "Missing --dest-dir=<dest-dir>"))

  (when (and (file-exists? *egg-recipes-dir*)
             (not (directory? *egg-recipes-dir*)))
    (die "~a exists but is not a directory." *egg-recipes-dir* ))

  (unless (file-exists? *egg-recipes-dir*)
    (create-directory *egg-recipes-dir*))

  (when (member "--force" args)
    (force? #t))

  (unless (directory? *eggs-dir*)
    (die "'~a' doesn't exist or is not a directory." *eggs-dir*))

  (for-each gen-recipe all-eggs))

) ;; end module
